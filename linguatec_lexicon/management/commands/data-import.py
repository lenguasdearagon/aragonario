import pandas as pd
from django.core.management.base import BaseCommand, CommandError
from linguatec_lexicon.models import Entry, Lexicon, GramaticalCategory, Word


def read_input_file(input_file):
    # TODO how to force dataframe to have 6 columns!!
    df = pd.DataFrame()

    xlsx = pd.ExcelFile(input_file)

    for sheet in xlsx.sheet_names:
        # we define na_values and keep_default_na because defaults na_values
        # includes empty string. We don't want that pandas replaces empty
        # cells with 'nan'
        partial = xlsx.parse(sheet, header=None, usecols='A:F', skiprows=[0, 1])
                             # names=['colA', 'colB', 'colC', 'colD', 'colE', 'colF'])
        df = df.append(partial, ignore_index=True, sort=False)

    df_obj = df.select_dtypes(['object'])
    df[df_obj.columns] = df_obj.apply(lambda x: x.str.strip())
    df = df.fillna('') # replace NaN with blank string

    # TODO change this confusing split
    #df[1] = df[1].str.split(' y ')

    return df


def split_data_frame_list(df, target_column):
    # thanks src https://gist.github.com/jlln/338b4b0b55bd6984f883#gistcomment-2676729
    """
    Splits a column with lists into rows

    Keyword arguments:
        df -- dataframe
        target_column -- name of column that contains lists
    """

    # create a new dataframe with each item in a seperate column, dropping rows with missing values
    col_df = pd.DataFrame(df[target_column].dropna(
    ).tolist(), index=df[target_column].dropna().index)

    # create a series with columns stacked as rows
    stacked = col_df.stack()

    # rename last column to 'idx'
    index = stacked.index.rename(names="idx", level=-1)
    new_df = pd.DataFrame(stacked, index=index, columns=[target_column])
    return new_df


def extract_gramcats(db):
    db_s = split_data_frame_list(db, 1)
    # src https://datascience.stackexchange.com/questions/29840/how-to-count-grouped-occurrences/29842#29842
    gramcats = db_s.groupby([1]).size().to_frame('count').reset_index()
    print('=========================')
    print('Gramatical categories')
    print(gramcats)
    print('=========================')
    return gramcats


def populate_models(db, gramcats):

    # populate gramcats
    for i in gramcats[1].tolist():
        GramaticalCategory.objects.create(
            abbreviation=i, title="autogenerated")

    # TODO allow to use an existing Lexicon or pass as args the new Lexicon parameters
    lex = Lexicon.objects.create(
        name="diccionario linguatec", src_language="es", dst_language="ar")

    for row in db.itertuples(name='Word'):
        # itertuples by default return the index as the first element of the tuple.

        # filter empty rows
        if pd.isnull(row):
            continue
        # TODO how to ignore empty rows in an elegant way?
        if pd.isna(row[1]) or pd.isnull(row[1]) or row[1] == '':
            continue

        # column A is word (required)
        w_str = row[1]

        # column B is gramcat (required) # TODO several gramcats issue #42
        g_str = row[2]

        if pd.notnull(g_str):
            # TODO change model to two foreign keys?
            #g_str = g_str[0]
            g = GramaticalCategory.objects.get(abbreviation=g_str)
            w = Word.objects.create(lexicon=lex, term=w_str, gramcat=g)

        else:
            print("ERROR\t%s missing gramatical category" % w_str)

        # column C is entry (required)
        en_str = row[3]
        en_strs = en_str.split(' // ')
        for s in en_strs:  # subelement
            Entry.objects.create(word=w, translation=s)

        # column E is example (optional)
        try:
            ex_str = row[5]
        except IndexError:
            continue
        else:
            if pd.notnull(ex_str) and ex_str != '':
                ex_strs = [x.strip() for x in ex_str.split('//')]
                for i, value in enumerate(ex_strs):  # subelement
                    if value:
                        we = w.entries.get(translation=en_strs[i])  # word entry
                        we.examples.create(phrase=ex_strs[i])

        # TODO column F is verb conjugation (only when gramcat is verb)


class Command(BaseCommand):

    def add_arguments(self, parser):
        parser.add_argument('input_file', type=str)

    def handle(self, *args, **options):

        input_file = options['input_file']

        self.stdout.write("INFO\tinput file: %s\n" % input_file, ending='')

        db = read_input_file(input_file)

        gramcats = extract_gramcats(db)

        populate_models(db, gramcats)
